"use strict";

// Global imports
const fs     = require("fs-extra");
const path   = require("path");
const {exec} = require("child_process");
const semver = require("semver");


// async function installDep(name, version) {
//   // TODO: Check if dep is already installed, and error if version is different
//   return new Promise(function(resolve, reject) {
//     log.trace_(`Installing ${name}@${version}... `);
//     var cmd = `npm install ${name}@${version}`;
//     if (/^win/.test(process.platform)) {  // If windows, ...
//       cmd = `${process.env.comspec} /c ${cmd}`;
//     }
//     exec(cmd, function(err) {
//       if (err != null) {
//         reject(err);
//       } else {
//         log.trace("Done");
//         resolve();
//       }
//     });
//   });
// }

function checkConflict(a, b, pkg) {
  if (a === b) return;
  
  let rngA = semver.validRange(a);
  let rngB = semver.validRange(b);
   
  if (rngA == null || rngB == null) {
    log.fatal(`Conflicting versions for package ${pkg}: "${a}" and "${b}"`);
  }
  if (!semver.intersects(a,b)) {
    log.fatal(`Conflicting versions for package ${pkg}: "${a}" and "${b}"`);
  }
}

async function install() {
  return new Promise(function(resolve, reject) {
    var cmd = "npm install";
    if (/^win/.test(process.platform)) {  // If windows, ...
      cmd = `${process.env.comspec} /c ${cmd}`;
    }
    exec(cmd, function(err) {
      if (err != null) {
        reject(err);
      } else {
        resolve();
      }
    });
  });
}


// TODO: If none are missing, don't install
// TODO: If there are conflicts, throw error


module.exports = {
  async process(deps) {
    log.trace_(`Processing ${deps.length} dependencies... `);
    
    // Paths
    let rootDir = path.join(__dirname, "../../");
    let packagePath = rootDir + "package.json";
    let copyPath    = rootDir + "package.tmp.json";
    let servPkgPath = rootDir + "package.services.json";
    
    if (fs.existsSync(copyPath)) {
      // Process was probably aborted in the middle of
      // an install, start over.
      fs.removeSync(packagePath);
      fs.moveSync(copyPath, packagePath);
    }
    
    // Read in data
    let pkg = require(packagePath);
    let pkgDeps = pkg.dependencies || {};
    let servPkg = fs.existsSync(servPkgPath) ? require(servPkgPath) : {};
    let servPkgDepsOld = servPkg.dependencies || {};
    let keyCountBefore = Object.keys(servPkgDepsOld).length;
    
    var added = 0;
    var updated = 0;
    
    var servPkgDepsNew = {};
    for (let d of deps) {
      if (servPkgDepsNew[d.name] != null) {
        checkConflict(servPkgDepsNew[d.name], d.version, d.name);
      }
      if (pkgDeps[d.name] != null) {
        checkConflict(pkgDeps[d.name], d.version, d.name);
      }
      
      servPkgDepsNew[d.name] = d.version;
      
      if (servPkgDepsOld[d.name] == null) {
        // Adding a package that didn't used to exist, we need to install it.
        added++;
      } else if (servPkgDepsOld[d.name] != servPkgDepsNew[d.name]) {
        updated++;
      }
    }
    let keyCountAfter = Object.keys(servPkgDepsNew).length;
    
    // Need to subtract 'added' to account for adding and removing packages at the same time.
    let removed = Math.max(0, keyCountBefore - (keyCountAfter - added));
    
    log.trace("Done");
    
    // If there were some added/removed, then update and
    if (added > 0 || updated > 0 || removed > 0) {
      log.trace_(`Installing dependencies (+${added}, ^${updated}, -${removed})... `);
      
      // Copy the package.json
      fs.copySync(packagePath, copyPath);
      
      pkg.dependencies = Object.assign({}, pkgDeps, servPkgDepsNew);
      fs.writeFileSync(packagePath, JSON.stringify(pkg));
      let servPkg = {"__notice__": "THIS FILE IS AUTOGENERATED, DO NOT MODIFY", dependencies: servPkgDepsNew};
      fs.writeFileSync(servPkgPath, JSON.stringify(servPkg));
      await install();
      
      // Clean up
      fs.removeSync(packagePath);
      fs.moveSync(copyPath, packagePath);
      log.trace("Done");
    } else {
      log.trace("Service dependencies up-to-date");
    }
  }
};